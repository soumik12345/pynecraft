{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pynecraft","title":"PyneCraft","text":"<p>An open-source implementation of a voxel-based game engine similar to MineCraft in Python. The primary purpose of this project is to act as personal hands-on journey to re-learn basic computer graphics and game development concepts.</p>"},{"location":"#installation-and-running","title":"Installation and Running","text":"<pre><code># clone the repository\ngit clone https://github.com/soumik12345/pynecraft\n\n# enter into the source directory\ncd pynecraft\n\n# install the core packages\npip install -e .[core]\n</code></pre> The game is run by running <code>main.py</code> <pre><code>NAME\n    main.py\n\nSYNOPSIS\n    main.py &lt;flags&gt;\n\nFLAGS\n    -w, --window_resolution=WINDOW_RESOLUTION\n        Type: Tuple\n        Default: (1600, 900)\n    -d, --depth_buffer_size=DEPTH_BUFFER_SIZE\n        Type: int\n        Default: 24\n    -b, --background_color=BACKGROUND_COLOR\n        Type: Optional\n        Default: [0, 0, 0]\n    --player_speed=PLAYER_SPEED\n        Type: float\n        Default: 0.005\n    --player_rotation_speed=PLAYER_ROTATION_SPEED\n        Type: float\n        Default: 0.003\n    -m, --mouse_sensitivity=MOUSE_SENSITIVITY\n        Type: float\n        Default: 0.002\n    --position=POSITION\n        Type: Tuple\n        Default: (0, 0, 1)\n    -y, --yaw=YAW\n        Type: float\n        Default: -90\n    --pitch=PITCH\n        Type: float\n        Default: 0\n    --field_of_view=FIELD_OF_VIEW\n        Type: float\n        Default: 50.0\n    -n, --near_plane_of_view_frustum=NEAR_PLANE_OF_VIEW_FRUSTUM\n        Type: float\n        Default: 0.1\n    --far_plane_of_view_frustum=FAR_PLANE_OF_VIEW_FRUSTUM\n        Type: float\n        Default: 2000.0\n    --pitch_max=PITCH_MAX\n        Type: float\n        Default: 89\n</code></pre>"},{"location":"#development-logs","title":"Development Logs","text":"<p>I'll be documenting my journey in the form of development logs:</p> <ul> <li>Devlog 0: A Basic Window System</li> <li>Devlog 1: Basic Mesh Rendering Pipeline</li> <li>Devlog 2: Add a basic first-persor camera and player system</li> </ul>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<ul> <li>Introduction to OpenGL</li> <li>Learn OpenGL</li> <li>PyGame Docs</li> <li>Coding Minecraft Live</li> <li>Creating MineCraft in C++ and OpenGL</li> <li>Creating a Voxel Engine (like Minecraft) from Scratch in Python</li> </ul>"},{"location":"devlogs/00_window_system/","title":"Devlog-0","text":""},{"location":"devlogs/00_window_system/#devlog-0-a-basic-window-system","title":"Devlog 0: A Basic Window System","text":"<p>The first step to build an open-source python implementation of a MineCraft-like engine or any game for that matter is to create a Window system that simply shows a blank screen. We do this by createing the <code>pynecraft.engine.PyneCraftEngine</code> class that is responsible for creating the window, setting up the OpenGL context, and running the main loop of the engine. The main loop of the engine is responsible for updating the game state, rendering, and handling events.</p> <p>Note</p> <p>The source code of this checkpoint can be found at PR #1. The source code is heavily documented.</p>"},{"location":"devlogs/01_mesh_rendering/","title":"Devlog-1","text":""},{"location":"devlogs/01_mesh_rendering/#devlog-1-basic-mesh-rendering-pipeline","title":"Devlog 1: Basic Mesh Rendering Pipeline","text":"<p>The next step is to get a very basic rendering pipeline up and running to render our first shape.</p>"},{"location":"devlogs/01_mesh_rendering/#handing-a-shader-program","title":"Handing a Shader Program","text":"<p>For this step, we create a class <code>pynecraft.shader_program.ShaderProgram</code> that encapsulates the handling of shaders by interacting directly with an OpenGL context provided by moderngl. This class also implements abstractions for reading the shader source code and setting the values of input and uniform variables to the vertex shader.</p>"},{"location":"devlogs/01_mesh_rendering/#writing-the-shaders","title":"Writing the Shaders","text":"<p>Shaders are specialized programs written in a C-like language called GLSL and are used in a graphics pipeline to control various aspects of rendering, such as lighting, texture mapping, and color computations. These programs run on the GPU and are essential for generating the visual effects seen in video games and computer-generated imagery in films.</p>"},{"location":"devlogs/01_mesh_rendering/#vertex-shader","title":"Vertex Shader","text":"<p>The vertex shader is the first programmable stage in the graphics pipeline. It processes vertex data. Each vertex's data might include positions, colors, normals, and texture coordinates. This makes it ideal to implement logics like transformations like rotation, scaling, translation, as well as lighting calculations based on vertex normals.</p> <p>We write a simple and straightforward vertex shader that takes vertices with positions and colors, passes those colors directly through to the fragment shader, and transforms the positions into clip space, preparing them for further processing by the GPU's rasterization stage.</p> <pre><code>// the shader is writter for OpenGL 3.3 core profile\n#version 330 core\n\n// input variables to the vertex shader\nlayout (location = 0) in vec3 in_position;\nlayout (location = 1) in vec3 in_color;\n\n// output variables from the vertex shader, passes the\n// color data to the fragment shader\nout vec3 color;\n\nvoid main() {\n    color = in_color;\n    // `gl_Position` is a predefined variable that must\n    // be set in every vertex shader\n    gl_Position = vec4(in_position, 1.0);\n}\n</code></pre>"},{"location":"devlogs/01_mesh_rendering/#fragment-shader","title":"Fragment Shader","text":"<p>Vertex shaders process each vertex individually and pass their output to the next stage (often a geometry shader or directly to the rasterizer). After rasterization, which turns geometric shapes into a screen-space grid of fragments, the fragment shader runs for each fragment to determine the final pixel color. They determine the color and other attributes of each pixel by processing data passed from the vertex shader. This makes it ideal to implement logics like applying textures to fragments and position-dependent effects like specular highlights, bump mapping, shadows, etc.</p> <p>We write a very simple fragment shader that takes an RGB color input for each fragment, adds full opacity to it, and outputs the resulting RGBA color.</p> <pre><code>// the shader is writter for OpenGL 3.3 core profile\n#version 330 core\n\n// output of the fragment shader that will store the\n// final color of the fragment (pixel) that is output\n// to the framebuffer\nlayout (location = 0) out vec4 frag_color;\n\n// input variable from the vertex shader\nin vec3 color;\n\nvoid main() {\n    // adds an alpha value to the color\n    frag_color = vec4(color, 1.0);\n}\n</code></pre>"},{"location":"devlogs/01_mesh_rendering/#a-hierarchy-of-meshes","title":"A Hierarchy of Meshes","text":"<p>A Mesh is basically a 3D object that is to be rendered in the 3D environment. In order to manage the logic of handling and rendering meshes, we create the abstract base class <code>pynecraft.mesh.base.BaseMesh</code> from which other meshes like <code>pynecraft.mesh.QuadMesh</code> can be inherited. All we need to define in the inherited mesh classes is the vertex data structure, the input attributes to the vertex shader corresponding to the vertex data structure, and the format of the vertex buffer object.</p> <p>These Mesh objects can be then put together in a <code>pynecraft.scene.Scene</code> which basically contains a list of meshes and how to render them, along with any additional logic for the update loop of the engine. The <code>Scene</code> basically denotes the 3D environment we're rendering and interacting with the in the game world.</p> <p>Note</p> <p>The source code of this checkpoint can be found at PR #2. The source code is heavily documented.</p>"},{"location":"devlogs/02_camera/","title":"Devlog-2","text":""},{"location":"devlogs/02_camera/#devlog-2-add-a-basic-first-persor-camera-and-player-system","title":"Devlog 2: Add a basic first-persor camera and player system","text":"<p>If you look at the rendering of the quad from the previous devlog, you'll notice that although the quad was suppossed to be a square with equal dimensions, its kinda stretched horizontally. This is because we're not taking the aspect ration of the window into account while translating the coordinates of the mesh vertices into OpenGL world coordinates. We're gonna fix this by creating a camera system.</p>"},{"location":"devlogs/02_camera/#camera","title":"Camera","text":"<p>We create a <code>pynecraft.camera.Camera</code> class designed to handle the position and orientation of a virtual camers within a 3D game world. It manages the camera's perspective projection and its transformation based on player input or other in-game events. The <code>Camera</code> class is initialized using a <code>pynecraft.parameters.CameraParameters</code> object.</p>"},{"location":"devlogs/02_camera/#field-of-view","title":"Field of View","text":"<p>I referred to the article FOV Calculation: Understanding Field of View in Photography By Teryani Riggs to understand the concept of horizontal and vertical field of view.</p> The figure is taken from the aforemention article. The term angle of view is not to be confused with the term field of view. The angle of view is the angular size of the view cone while the field of view is the maximum area our camera can capture at a given lens focal length of a lens. <p>For a virual camera, field of view refers to the angle between the top and bottom of the view frustum. It determines how much of the scene is visible vertically from the camera's perspective. A larger field of view makes more of the scene visible vertically, which can make the game feel more immersive.</p> <p>The horizontal field of view is derived from the vertical field of view using the aspect ratio of the game window. This ensures that the field of view remains consistent and proportionate across different screen sizes and aspect ratios. By adjusting the vertical field of view and the aspect ratio, the horizontal field of view is automatically adjusted to provide a correct and visually pleasing perspective.</p> <p>From this idea, we can establish the relation between FOV and horizontal FOX as the following:</p> \\[ tan(\\frac{FOV_h}{2}) = Aspect Ratio * tan(\\frac{FOV_v}{2}) \\] <p>Therefore, horizontal FOV can be expressed as the following</p> \\[ FOV_h = 2 * arctan(Aspect Ratio * tan(\\frac{FOV_v}{2})) \\]"},{"location":"devlogs/02_camera/#first-person-player","title":"First-person Player","text":"<p>If you really think of it, a first-person player is basically a camera with first-person keyboard and mouse controls. Hence we implment the <code>pynecraft.player.FirstPersonPlayer</code> class by inheriting from <code>Camera</code> and adding keyboard and mouse controls to control the movement and rotation of the camera.</p> <p></p> <p>Note</p> <p>The source code of this checkpoint can be found at PR #3. The source code is heavily documented.</p>"},{"location":"source/camera/","title":"Camera","text":""},{"location":"source/camera/#camera","title":"Camera","text":""},{"location":"source/camera/#pynecraft.camera.Camera","title":"<code>Camera</code>","text":"<p>A camera class designed to handle the position and orientation of a virtual camers within a 3D game world. It manages the camera's perspective projection and its transformation based on player input or other in-game events.</p> <p>Parameters:</p> Name Type Description Default <code>window_resolution</code> <code>Tuple[float, float]</code> <p>The resolution of the window.</p> required <code>camera_parameters</code> <code>CameraParameters</code> <p>The parameters of the camera.</p> required Source code in <code>pynecraft/camera.py</code> <pre><code>class Camera:\n    \"\"\"A camera class designed to handle the position and orientation of a\n    virtual camers within a 3D game world. It manages the camera's perspective\n    projection and its transformation based on player input or other in-game\n    events.\n\n    Args:\n        window_resolution (Tuple[float, float]): The resolution of the window.\n        camera_parameters (CameraParameters): The parameters of the camera.\n    \"\"\"\n\n    def __init__(\n        self,\n        window_resolution: Tuple[float, float],\n        camera_parameters: CameraParameters,\n    ) -&gt; None:\n        self.window_resolution = glm.vec2(window_resolution)\n        self.position = glm.vec3(camera_parameters.position)\n        self.yaw = glm.radians(camera_parameters.yaw)\n        self.pitch = glm.radians(camera_parameters.pitch)\n        self.field_of_view = camera_parameters.field_of_view\n        self.near_plane_of_view_frustum = camera_parameters.near_plane_of_view_frustum\n        self.far_plane_of_view_frustum = camera_parameters.far_plane_of_view_frustum\n        self.pitch_max = camera_parameters.pitch_max\n\n        self.aspect_ratio = self.window_resolution.x / self.window_resolution.y\n\n        # The angle between the top and bottom of the view frustum. It determines how\n        # much of the scene is visible vertically from the camera's perspective.\n        # A larger vertical field of view makes more of the scene visible vertically,\n        # which can make the game feel more immersive.\n        self.vertical_field_of_view = glm.radians(self.field_of_view)\n\n        # The horizontal field of view is derived from the vertical field of view using\n        # the aspect ratio of the game window. This ensures that the field of view remains\n        # consistent and proportionate across different screen sizes and aspect ratios. By\n        # adjusting the vertical field of view and the aspect ratio, the horizontal field\n        # of view is automatically adjusted to provide a correct and visually pleasing\n        # perspective.\n        self.horizontal_field_of_view = 2 * math.atan(\n            math.tan(self.vertical_field_of_view / 2) * self.aspect_ratio\n        )\n\n        self.up = glm.vec3(0.0, 1.0, 0.0)\n        self.right = glm.vec3(1.0, 0.0, 0.0)\n        self.forward = glm.vec3(0.0, 0.0, -1.0)\n\n        self.projection_matrix = glm.perspective(\n            self.vertical_field_of_view,\n            self.aspect_ratio,\n            self.near_plane_of_view_frustum,\n            self.far_plane_of_view_frustum,\n        )\n        self.view_matrix = glm.mat4()\n\n    def update_vectors(self):\n        \"\"\"Update the camera vectors.\"\"\"\n        self.forward.x = glm.cos(self.yaw) * glm.cos(self.pitch)\n        self.forward.y = glm.sin(self.pitch)\n        self.forward.z = glm.sin(self.yaw) * glm.cos(self.pitch)\n\n        self.forward = glm.normalize(self.forward)\n        self.right = glm.normalize(glm.cross(self.forward, glm.vec3(0.0, 1.0, 0.0)))\n        self.up = glm.normalize(glm.cross(self.right, self.forward))\n\n    def update_view_matrix(self):\n        \"\"\"Update the view matrix.\"\"\"\n        self.view_matrix = glm.lookAt(\n            self.position, self.position + self.forward, self.up\n        )\n\n    def update(self):\n        \"\"\"Update the camera vectors and view matrix based on the controls.\"\"\"\n        self.update_vectors()\n        self.update_view_matrix()\n\n    def rotate_pitch(self, vertical_offset):\n        \"\"\"Rotate the camera pitch.\"\"\"\n        self.pitch -= vertical_offset\n        self.pitch = glm.clamp(self.pitch, -self.pitch_max, self.pitch_max)\n\n    def rotate_yaw(self, horizontal_offset):\n        \"\"\"Rotate the camera yaw.\"\"\"\n        self.yaw += horizontal_offset\n\n    def move_left(self, velocity):\n        \"\"\"Move the camera left.\"\"\"\n        self.position -= self.right * velocity\n\n    def move_right(self, velocity):\n        \"\"\"Move the camera right.\"\"\"\n        self.position += self.right * velocity\n\n    def move_up(self, velocity):\n        \"\"\"Move the camera up.\"\"\"\n        self.position += self.up * velocity\n\n    def move_down(self, velocity):\n        \"\"\"Move the camera down.\"\"\"\n        self.position -= self.up * velocity\n\n    def move_forward(self, velocity):\n        \"\"\"Move the camera forward.\"\"\"\n        self.position += self.forward * velocity\n\n    def move_backward(self, velocity):\n        \"\"\"Move the camera backward.\"\"\"\n        self.position -= self.forward * velocity\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.move_backward","title":"<code>move_backward(velocity)</code>","text":"<p>Move the camera backward.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def move_backward(self, velocity):\n    \"\"\"Move the camera backward.\"\"\"\n    self.position -= self.forward * velocity\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.move_down","title":"<code>move_down(velocity)</code>","text":"<p>Move the camera down.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def move_down(self, velocity):\n    \"\"\"Move the camera down.\"\"\"\n    self.position -= self.up * velocity\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.move_forward","title":"<code>move_forward(velocity)</code>","text":"<p>Move the camera forward.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def move_forward(self, velocity):\n    \"\"\"Move the camera forward.\"\"\"\n    self.position += self.forward * velocity\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.move_left","title":"<code>move_left(velocity)</code>","text":"<p>Move the camera left.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def move_left(self, velocity):\n    \"\"\"Move the camera left.\"\"\"\n    self.position -= self.right * velocity\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.move_right","title":"<code>move_right(velocity)</code>","text":"<p>Move the camera right.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def move_right(self, velocity):\n    \"\"\"Move the camera right.\"\"\"\n    self.position += self.right * velocity\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.move_up","title":"<code>move_up(velocity)</code>","text":"<p>Move the camera up.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def move_up(self, velocity):\n    \"\"\"Move the camera up.\"\"\"\n    self.position += self.up * velocity\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.rotate_pitch","title":"<code>rotate_pitch(vertical_offset)</code>","text":"<p>Rotate the camera pitch.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def rotate_pitch(self, vertical_offset):\n    \"\"\"Rotate the camera pitch.\"\"\"\n    self.pitch -= vertical_offset\n    self.pitch = glm.clamp(self.pitch, -self.pitch_max, self.pitch_max)\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.rotate_yaw","title":"<code>rotate_yaw(horizontal_offset)</code>","text":"<p>Rotate the camera yaw.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def rotate_yaw(self, horizontal_offset):\n    \"\"\"Rotate the camera yaw.\"\"\"\n    self.yaw += horizontal_offset\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.update","title":"<code>update()</code>","text":"<p>Update the camera vectors and view matrix based on the controls.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def update(self):\n    \"\"\"Update the camera vectors and view matrix based on the controls.\"\"\"\n    self.update_vectors()\n    self.update_view_matrix()\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.update_vectors","title":"<code>update_vectors()</code>","text":"<p>Update the camera vectors.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def update_vectors(self):\n    \"\"\"Update the camera vectors.\"\"\"\n    self.forward.x = glm.cos(self.yaw) * glm.cos(self.pitch)\n    self.forward.y = glm.sin(self.pitch)\n    self.forward.z = glm.sin(self.yaw) * glm.cos(self.pitch)\n\n    self.forward = glm.normalize(self.forward)\n    self.right = glm.normalize(glm.cross(self.forward, glm.vec3(0.0, 1.0, 0.0)))\n    self.up = glm.normalize(glm.cross(self.right, self.forward))\n</code></pre>"},{"location":"source/camera/#pynecraft.camera.Camera.update_view_matrix","title":"<code>update_view_matrix()</code>","text":"<p>Update the view matrix.</p> Source code in <code>pynecraft/camera.py</code> <pre><code>def update_view_matrix(self):\n    \"\"\"Update the view matrix.\"\"\"\n    self.view_matrix = glm.lookAt(\n        self.position, self.position + self.forward, self.up\n    )\n</code></pre>"},{"location":"source/engine/","title":"Engine","text":""},{"location":"source/engine/#the-pynecraft-engine","title":"The PyneCraft Engine","text":""},{"location":"source/engine/#pynecraft.engine.PyneCraftEngine","title":"<code>PyneCraftEngine</code>","text":"<p>The main class of the PyneCraft engine. It is responsible for creating the window, setting up the OpenGL context, and running the main loop of the engine. The main loop of the engine is responsible for updating the game state, rendering, and handling events.</p> <p>Parameters:</p> Name Type Description Default <code>engine_parameters</code> <code>EngineParameters</code> <p>The parameters of the PyneCraft.</p> required Source code in <code>pynecraft/engine.py</code> <pre><code>class PyneCraftEngine:\n    \"\"\"The main class of the PyneCraft engine. It is responsible for\n    creating the window, setting up the OpenGL context, and running the\n    main loop of the engine. The main loop of the engine is responsible\n    for updating the game state, rendering, and handling events.\n\n    Args:\n        engine_parameters (EngineParameters): The parameters of the PyneCraft.\n    \"\"\"\n\n    def __init__(self, engine_parameters: EngineParameters) -&gt; None:\n        self.window_resolution = glm.vec2(engine_parameters.window_resolution)\n        self.depth_buffer_size = engine_parameters.depth_buffer_size\n        self.background_color = engine_parameters.background_color\n\n        pygame.init()\n        self.set_opengl_attributes()\n\n        # Create the display surface\n        pygame.display.set_mode(\n            self.window_resolution, flags=pygame.DOUBLEBUF | pygame.OPENGL\n        )\n\n        # Create the opengl context\n        self.opengl_context = moderngl.create_context()\n\n        # Enable specific OpenGL capabilities for the rendering context.\n        # `moderngl.DEPTH_TEST` enables depth testing which ensures that pixels\n        # closer to the camera obscure those further away, maintaining the\n        # proper visual order of objects.\n        # `moderngl.CULL_FACE` enables face culling which is a technique for\n        # improving rendering performance by not drawing faces of polygons that\n        # are not visible to the camera. Typically, this involves not rendering\n        # the back faces of objects, assuming the front faces are sufficient to\n        # represent the visible geometry.\n        # `moderngl.BLEND` enables blending which is the process of combining the\n        # color of a source pixel with the color of a destination pixel based on\n        # their alpha values. It is essential for rendering transparent and\n        # semi-transparent objects correctly.\n        self.opengl_context.enable(\n            moderngl.DEPTH_TEST | moderngl.CULL_FACE | moderngl.BLEND\n        )\n\n        # Set the garbage collection mode of the OpenGL context to \"auto\".\n        # This enables the OpenGL context to automatically manages the deletion of\n        # OpenGL objects (like buffers, textures, and shaders) that are no longer\n        # in use. This helps prevent memory leaks and ensures that resources are\n        # freed up when they are no longer needed.\n        self.opengl_context.gc_mode = \"auto\"\n\n        self.clock = pygame.time.Clock()\n        self.delta_time = 0  # The time elapsed since the last frame.\n        self.time = 0\n\n        self.is_engine_running = True\n\n        self.player = FirstPersonPlayer(\n            window_resolution=engine_parameters.window_resolution,\n            player_parameters=engine_parameters.player_parameters,\n        )\n        self.shader_program = ShaderProgram(\n            opengl_context=self.opengl_context, player=self.player, shader_dir=\"shaders\"\n        )\n        self.scene = Scene(\n            opengl_context=self.opengl_context, program=self.shader_program.program\n        )\n\n    def set_opengl_attributes(self) -&gt; None:\n        \"\"\"Set the values of several attributes for the OpenGL context before\n        creating the display surface.\n        \"\"\"\n        # Set the version of the OpenGL context to 3.3\n        pygame.display.gl_set_attribute(pygame.GL_CONTEXT_MAJOR_VERSION, 3)\n        pygame.display.gl_set_attribute(pygame.GL_CONTEXT_MINOR_VERSION, 3)\n\n        # Set the subset of the OpenGL API to be used is the core profile.\n        # The core profile includes only the modern, streamlined parts of\n        # OpenGL, removing deprecated functions and features.\n        pygame.display.gl_set_attribute(\n            pygame.GL_CONTEXT_PROFILE_MASK, pygame.GL_CONTEXT_PROFILE_CORE\n        )\n\n        # Set the size of the depth buffer in bits. The depth buffer is used\n        # to handle depth information to determine which objects are in front\n        # of others in a 3D scene by keeping track of the depth of each pixel.\n        pygame.display.gl_set_attribute(pygame.GL_DEPTH_SIZE, self.depth_buffer_size)\n\n    def update(self) -&gt; None:\n        \"\"\"Update the game state using the core game logic.\"\"\"\n        self.player.update(self.delta_time)\n        self.shader_program.update()\n        self.scene.update()\n        self.delta_time = self.clock.tick()\n        self.time = pygame.time.get_ticks() * 1e-3\n        pygame.display.set_caption(f\"PyneCraft | FPS: {self.clock.get_fps()}\")\n\n    def render(self) -&gt; None:\n        \"\"\"Render the game state to the screen.\"\"\"\n        self.opengl_context.clear(*self.background_color)\n        self.scene.render()\n        pygame.display.flip()\n\n    def handle_events(self) -&gt; None:\n        \"\"\"Handle events such as user input and window events.\"\"\"\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT or (\n                event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE\n            ):\n                self.is_engine_running = False\n\n    def run(self) -&gt; None:\n        \"\"\"Run the main loop of the engine, which updates the game state, renders the\n        game, and handles events.\n        \"\"\"\n        while self.is_engine_running:\n            self.update()\n            self.render()\n            self.handle_events()\n        pygame.quit()\n        sys.exit()\n</code></pre>"},{"location":"source/engine/#pynecraft.engine.PyneCraftEngine.handle_events","title":"<code>handle_events()</code>","text":"<p>Handle events such as user input and window events.</p> Source code in <code>pynecraft/engine.py</code> <pre><code>def handle_events(self) -&gt; None:\n    \"\"\"Handle events such as user input and window events.\"\"\"\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT or (\n            event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE\n        ):\n            self.is_engine_running = False\n</code></pre>"},{"location":"source/engine/#pynecraft.engine.PyneCraftEngine.render","title":"<code>render()</code>","text":"<p>Render the game state to the screen.</p> Source code in <code>pynecraft/engine.py</code> <pre><code>def render(self) -&gt; None:\n    \"\"\"Render the game state to the screen.\"\"\"\n    self.opengl_context.clear(*self.background_color)\n    self.scene.render()\n    pygame.display.flip()\n</code></pre>"},{"location":"source/engine/#pynecraft.engine.PyneCraftEngine.run","title":"<code>run()</code>","text":"<p>Run the main loop of the engine, which updates the game state, renders the game, and handles events.</p> Source code in <code>pynecraft/engine.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"Run the main loop of the engine, which updates the game state, renders the\n    game, and handles events.\n    \"\"\"\n    while self.is_engine_running:\n        self.update()\n        self.render()\n        self.handle_events()\n    pygame.quit()\n    sys.exit()\n</code></pre>"},{"location":"source/engine/#pynecraft.engine.PyneCraftEngine.set_opengl_attributes","title":"<code>set_opengl_attributes()</code>","text":"<p>Set the values of several attributes for the OpenGL context before creating the display surface.</p> Source code in <code>pynecraft/engine.py</code> <pre><code>def set_opengl_attributes(self) -&gt; None:\n    \"\"\"Set the values of several attributes for the OpenGL context before\n    creating the display surface.\n    \"\"\"\n    # Set the version of the OpenGL context to 3.3\n    pygame.display.gl_set_attribute(pygame.GL_CONTEXT_MAJOR_VERSION, 3)\n    pygame.display.gl_set_attribute(pygame.GL_CONTEXT_MINOR_VERSION, 3)\n\n    # Set the subset of the OpenGL API to be used is the core profile.\n    # The core profile includes only the modern, streamlined parts of\n    # OpenGL, removing deprecated functions and features.\n    pygame.display.gl_set_attribute(\n        pygame.GL_CONTEXT_PROFILE_MASK, pygame.GL_CONTEXT_PROFILE_CORE\n    )\n\n    # Set the size of the depth buffer in bits. The depth buffer is used\n    # to handle depth information to determine which objects are in front\n    # of others in a 3D scene by keeping track of the depth of each pixel.\n    pygame.display.gl_set_attribute(pygame.GL_DEPTH_SIZE, self.depth_buffer_size)\n</code></pre>"},{"location":"source/engine/#pynecraft.engine.PyneCraftEngine.update","title":"<code>update()</code>","text":"<p>Update the game state using the core game logic.</p> Source code in <code>pynecraft/engine.py</code> <pre><code>def update(self) -&gt; None:\n    \"\"\"Update the game state using the core game logic.\"\"\"\n    self.player.update(self.delta_time)\n    self.shader_program.update()\n    self.scene.update()\n    self.delta_time = self.clock.tick()\n    self.time = pygame.time.get_ticks() * 1e-3\n    pygame.display.set_caption(f\"PyneCraft | FPS: {self.clock.get_fps()}\")\n</code></pre>"},{"location":"source/parameters/","title":"Parameters","text":""},{"location":"source/parameters/#parameters","title":"Parameters","text":""},{"location":"source/parameters/#pynecraft.parameters.CameraParameters","title":"<code>CameraParameters</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>Camera parameters.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Tuple[float, float, float]</code> <p>The position of the camera.</p> required <code>yaw</code> <code>float</code> <p>The yaw of the camera in degrees.</p> required <code>pitch</code> <code>float</code> <p>The pitch of the camera in degrees.</p> required <code>field_of_view</code> <code>float</code> <p>The field of view of the camera in degrees. This is the extent of the observable world that is seen at any given moment by the camera (or the player's eye) in a game.</p> required <code>near_plane_of_view_frustum</code> <code>float</code> <p>The distance of near clipping plane of the view frustum from the point of view.</p> required <code>far_plane_of_view_frustum</code> <code>float</code> <p>The distance of far clipping plane of the view frustum from the point of view.</p> required <code>pitch_max</code> <code>float</code> <p>The maximum pitch of the camera in degrees.</p> required Source code in <code>pynecraft/parameters.py</code> <pre><code>class CameraParameters(BaseModel):\n    \"\"\"Camera parameters.\n\n    Args:\n        position (Tuple[float, float, float]): The position of the camera.\n        yaw (float): The yaw of the camera in degrees.\n        pitch (float): The pitch of the camera in degrees.\n        field_of_view (float): The field of view of the camera in degrees.\n            This is the extent of the observable world that is seen at any\n            given moment by the camera (or the player's eye) in a game.\n        near_plane_of_view_frustum (float): The distance of near clipping\n            plane of the view frustum from the point of view.\n        far_plane_of_view_frustum (float): The distance of far clipping\n            plane of the view frustum from the point of view.\n        pitch_max (float): The maximum pitch of the camera in degrees.\n    \"\"\"\n\n    position: Tuple[float, float, float] = (0, 0, 1)\n    yaw: float = -90\n    pitch: float = 0\n    field_of_view: float = 50.0\n    near_plane_of_view_frustum: float = 0.1\n    far_plane_of_view_frustum: float = 2000.0\n    pitch_max: float = 89\n</code></pre>"},{"location":"source/parameters/#pynecraft.parameters.EngineParameters","title":"<code>EngineParameters</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>PyneCraft engine parameters.</p> <p>Parameters:</p> Name Type Description Default <code>window_resolution</code> <code>Tuple[int, int]</code> <p>The resolution of the window in pixels.</p> required <code>depth_buffer_size</code> <code>int</code> <p>The size of the depth buffer in bits. A larger depth buffer size can improve the visual quality of the 3D scene by reducing artifacts such as z-fighting, where two surfaces are so close together that the depth buffer cannot distinguish which is in front. Common values for depth buffer size are <code>16</code>, <code>24</code>, or <code>32</code> bits, with <code>24</code> bits being a typical choice for balancing performance and precision.</p> required <code>background_color</code> <code>Optional[Tuple[int, int, int]]</code> <p>The background color of the window.</p> required <code>player_parameters</code> <code>FirstPersonPlayerParameters</code> <p>The parameters of the player.</p> required Source code in <code>pynecraft/parameters.py</code> <pre><code>class EngineParameters(BaseModel):\n    \"\"\"PyneCraft engine parameters.\n\n    Args:\n        window_resolution (Tuple[int, int]): The resolution of the window\n            in pixels.\n        depth_buffer_size (int): The size of the depth buffer in bits.\n            A larger depth buffer size can improve the visual quality\n            of the 3D scene by reducing artifacts such as z-fighting,\n            where two surfaces are so close together that the depth buffer\n            cannot distinguish which is in front. Common values for depth\n            buffer size are `16`, `24`, or `32` bits, with `24` bits being\n            a typical choice for balancing performance and precision.\n        background_color (Optional[Tuple[int, int, int]], optional): The background\n            color of the window.\n        player_parameters (FirstPersonPlayerParameters): The parameters of the player.\n    \"\"\"\n\n    window_resolution: Tuple[int, int]\n    depth_buffer_size: int\n    background_color: Tuple[int, int, int] = (0, 0, 0)\n    player_parameters: FirstPersonPlayerParameters\n</code></pre>"},{"location":"source/parameters/#pynecraft.parameters.FirstPersonPlayerParameters","title":"<code>FirstPersonPlayerParameters</code>","text":"<p>             Bases: <code>BaseModel</code></p> <p>First person player parameters.</p> <p>Parameters:</p> Name Type Description Default <code>player_speed</code> <code>float</code> <p>The speed of the player.</p> required <code>player_rotation_speed</code> <code>float</code> <p>The rotation speed of the player.</p> required <code>mouse_sensitivity</code> <code>float</code> <p>The sensitivity of the mouse control.</p> required <code>camera_parameters</code> <code>CameraParameters</code> <p>The parameters of the camera.</p> required Source code in <code>pynecraft/parameters.py</code> <pre><code>class FirstPersonPlayerParameters(BaseModel):\n    \"\"\"First person player parameters.\n\n    Args:\n        player_speed (float): The speed of the player.\n        player_rotation_speed (float): The rotation speed of the player.\n        mouse_sensitivity (float): The sensitivity of the mouse control.\n        camera_parameters (CameraParameters): The parameters of the camera.\n    \"\"\"\n\n    player_speed: float = 5e-3\n    player_rotation_speed: float = 3e-3\n    mouse_sensitivity: float = 2e-3\n    camera_parameters: CameraParameters\n</code></pre>"},{"location":"source/player/","title":"Player","text":""},{"location":"source/player/#player","title":"Player","text":""},{"location":"source/player/#pynecraft.player.FirstPersonPlayer","title":"<code>FirstPersonPlayer</code>","text":"<p>             Bases: <code>Camera</code></p> <p>Manages the first-person player's movement and camera control within the 3D game world.</p> <p>Parameters:</p> Name Type Description Default <code>window_resolution</code> <code>Tuple[float, float]</code> <p>The resolution of the window.</p> required <code>player_parameters</code> <code>FirstPersonPlayerParameters</code> <p>The parameters of the first-person player.</p> required Source code in <code>pynecraft/player.py</code> <pre><code>class FirstPersonPlayer(Camera):\n    \"\"\"Manages the first-person player's movement and camera control within the 3D game world.\n\n    Args:\n        window_resolution (Tuple[float, float]): The resolution of the window.\n        player_parameters (FirstPersonPlayerParameters): The parameters of the first-person player.\n    \"\"\"\n\n    def __init__(\n        self,\n        window_resolution: Tuple[float, float],\n        player_parameters: FirstPersonPlayerParameters,\n    ) -&gt; None:\n        self.player_speed = player_parameters.player_speed\n        self.player_rotation_speed = player_parameters.player_rotation_speed\n        self.mouse_sensitivity = player_parameters.mouse_sensitivity\n        super().__init__(\n            window_resolution=window_resolution,\n            camera_parameters=player_parameters.camera_parameters,\n        )\n\n    def keyboard_control(self, delta_time: float):\n        \"\"\"Handles the keyboard input for controlling the player's movement.\n\n        Args:\n            delta_time (float): The time elapsed since the last frame.\n        \"\"\"\n        key_state = pygame.key.get_pressed()\n        velocity = self.player_speed * delta_time\n        if key_state[pygame.K_w]:\n            self.move_forward(velocity)\n        if key_state[pygame.K_s]:\n            self.move_backward(velocity)\n        if key_state[pygame.K_a]:\n            self.move_left(velocity)\n        if key_state[pygame.K_d]:\n            self.move_right(velocity)\n        if key_state[pygame.K_q]:\n            self.move_up(velocity)\n        if key_state[pygame.K_e]:\n            self.move_down(velocity)\n\n    def mouse_control(self):\n        \"\"\"Handles the mouse input for controlling the player's camera orientation.\"\"\"\n        mouse_change_horizontal, mouse_change_vertical = pygame.mouse.get_rel()\n        if mouse_change_horizontal:\n            self.rotate_yaw(\n                horizontal_offset=mouse_change_horizontal * self.mouse_sensitivity\n            )\n        if mouse_change_vertical:\n            self.rotate_pitch(\n                vertical_offset=mouse_change_vertical * self.mouse_sensitivity\n            )\n\n    def update(self, delta_time: float):\n        \"\"\"Update the player's movement and camera control using the core game logic.\n\n        Args:\n            delta_time (float): The time elapsed since the last frame.\n        \"\"\"\n        self.keyboard_control(delta_time=delta_time)\n        self.mouse_control()\n        super().update()\n</code></pre>"},{"location":"source/player/#pynecraft.player.FirstPersonPlayer.keyboard_control","title":"<code>keyboard_control(delta_time)</code>","text":"<p>Handles the keyboard input for controlling the player's movement.</p> <p>Parameters:</p> Name Type Description Default <code>delta_time</code> <code>float</code> <p>The time elapsed since the last frame.</p> required Source code in <code>pynecraft/player.py</code> <pre><code>def keyboard_control(self, delta_time: float):\n    \"\"\"Handles the keyboard input for controlling the player's movement.\n\n    Args:\n        delta_time (float): The time elapsed since the last frame.\n    \"\"\"\n    key_state = pygame.key.get_pressed()\n    velocity = self.player_speed * delta_time\n    if key_state[pygame.K_w]:\n        self.move_forward(velocity)\n    if key_state[pygame.K_s]:\n        self.move_backward(velocity)\n    if key_state[pygame.K_a]:\n        self.move_left(velocity)\n    if key_state[pygame.K_d]:\n        self.move_right(velocity)\n    if key_state[pygame.K_q]:\n        self.move_up(velocity)\n    if key_state[pygame.K_e]:\n        self.move_down(velocity)\n</code></pre>"},{"location":"source/player/#pynecraft.player.FirstPersonPlayer.mouse_control","title":"<code>mouse_control()</code>","text":"<p>Handles the mouse input for controlling the player's camera orientation.</p> Source code in <code>pynecraft/player.py</code> <pre><code>def mouse_control(self):\n    \"\"\"Handles the mouse input for controlling the player's camera orientation.\"\"\"\n    mouse_change_horizontal, mouse_change_vertical = pygame.mouse.get_rel()\n    if mouse_change_horizontal:\n        self.rotate_yaw(\n            horizontal_offset=mouse_change_horizontal * self.mouse_sensitivity\n        )\n    if mouse_change_vertical:\n        self.rotate_pitch(\n            vertical_offset=mouse_change_vertical * self.mouse_sensitivity\n        )\n</code></pre>"},{"location":"source/player/#pynecraft.player.FirstPersonPlayer.update","title":"<code>update(delta_time)</code>","text":"<p>Update the player's movement and camera control using the core game logic.</p> <p>Parameters:</p> Name Type Description Default <code>delta_time</code> <code>float</code> <p>The time elapsed since the last frame.</p> required Source code in <code>pynecraft/player.py</code> <pre><code>def update(self, delta_time: float):\n    \"\"\"Update the player's movement and camera control using the core game logic.\n\n    Args:\n        delta_time (float): The time elapsed since the last frame.\n    \"\"\"\n    self.keyboard_control(delta_time=delta_time)\n    self.mouse_control()\n    super().update()\n</code></pre>"},{"location":"source/scene/","title":"Scene","text":""},{"location":"source/scene/#scene","title":"Scene","text":""},{"location":"source/scene/#pynecraft.scene.Scene","title":"<code>Scene</code>","text":"<p>A scene that defines a collection of meshes and renders them.</p> <p>Parameters:</p> Name Type Description Default <code>opengl_context</code> <code>Context</code> <p>The OpenGL context.</p> required <code>program</code> <code>Program</code> <p>The shader program used to render the scene.</p> required Source code in <code>pynecraft/scene.py</code> <pre><code>class Scene:\n    \"\"\"A scene that defines a collection of meshes and renders them.\n\n    Args:\n        opengl_context (moderngl.Context): The OpenGL context.\n        program (moderngl.Program): The shader program used to render the scene.\n    \"\"\"\n\n    def __init__(\n        self, opengl_context: moderngl.Context, program: moderngl.Program\n    ) -&gt; None:\n        self.mesh = QuadMesh(opengl_context=opengl_context, program=program)\n\n    def update(self) -&gt; None:\n        pass\n\n    def render(self):\n        \"\"\"Render the scene.\"\"\"\n        self.mesh.render()\n</code></pre>"},{"location":"source/scene/#pynecraft.scene.Scene.render","title":"<code>render()</code>","text":"<p>Render the scene.</p> Source code in <code>pynecraft/scene.py</code> <pre><code>def render(self):\n    \"\"\"Render the scene.\"\"\"\n    self.mesh.render()\n</code></pre>"},{"location":"source/shader_program/","title":"Shader-Program-Handler","text":""},{"location":"source/shader_program/#the-shader-program-handler","title":"The Shader Program Handler","text":""},{"location":"source/shader_program/#pynecraft.shader_program.ShaderProgram","title":"<code>ShaderProgram</code>","text":"<p>ShaderProgram encapsulates the handling of shaders by interacting directly with an OpenGL context provided by moderngl.</p> <p>Parameters:</p> Name Type Description Default <code>opengl_context</code> <code>Context</code> <p>The OpenGL context.</p> required <code>shader_dir</code> <code>str</code> <p>The directory containing the vertex and fragment shader source code files.</p> required Source code in <code>pynecraft/shader_program.py</code> <pre><code>class ShaderProgram:\n    \"\"\"ShaderProgram encapsulates the handling of shaders by interacting\n    directly with an OpenGL context provided by moderngl.\n\n    Args:\n        opengl_context (moderngl.Context): The OpenGL context.\n        shader_dir (str): The directory containing the vertex and fragment\n            shader source code files.\n    \"\"\"\n\n    def __init__(\n        self,\n        opengl_context: moderngl.Context,\n        player: FirstPersonPlayer,\n        shader_dir: str,\n    ) -&gt; None:\n        self.opengl_context = opengl_context\n        self.player = player\n\n        self.program = self.get_program(shader_dir=shader_dir)\n        self.set_uniforms()\n\n    def get_program(self, shader_dir: str) -&gt; moderngl.Program:\n        \"\"\"Create a shader program from the vertex and fragment shader source\n\n        Args:\n            shader_dir (str): The directory containing the vertex and fragment\n                shader source code files.\n        \"\"\"\n        assert os.path.isdir(\n            shader_dir\n        ), f\"Shader directory '{shader_dir}' does not exist.\"\n\n        with open(os.path.join(shader_dir, \"vertex_shader.glsl\"), \"r\") as file:\n            vertex_shader_source = file.read()\n\n        with open(os.path.join(shader_dir, \"fragment_shader.glsl\"), \"r\") as file:\n            fragment_shader_source = file.read()\n\n        return self.opengl_context.program(\n            vertex_shader=vertex_shader_source, fragment_shader=fragment_shader_source\n        )\n\n    def set_uniforms(self):\n        \"\"\"Set the uniform variables of the shader program, the values of which\n        remain constant for all vertices processed during a single draw call.\n        \"\"\"\n        # Set the projection matrix uniform variable to the vertex shader\n        self.program[\"m_proj\"].write(self.player.projection_matrix)\n        # Set the model matrix uniform variable to the vertex shader\n        self.program[\"m_model\"].write(glm.mat4())\n\n    def update(self):\n        \"\"\"Update the uniform variables of the shader program.\"\"\"\n        # Set the view matrix uniform variable to the vertex shader\n        self.program[\"m_view\"].write(self.player.view_matrix)\n</code></pre>"},{"location":"source/shader_program/#pynecraft.shader_program.ShaderProgram.get_program","title":"<code>get_program(shader_dir)</code>","text":"<p>Create a shader program from the vertex and fragment shader source</p> <p>Parameters:</p> Name Type Description Default <code>shader_dir</code> <code>str</code> <p>The directory containing the vertex and fragment shader source code files.</p> required Source code in <code>pynecraft/shader_program.py</code> <pre><code>def get_program(self, shader_dir: str) -&gt; moderngl.Program:\n    \"\"\"Create a shader program from the vertex and fragment shader source\n\n    Args:\n        shader_dir (str): The directory containing the vertex and fragment\n            shader source code files.\n    \"\"\"\n    assert os.path.isdir(\n        shader_dir\n    ), f\"Shader directory '{shader_dir}' does not exist.\"\n\n    with open(os.path.join(shader_dir, \"vertex_shader.glsl\"), \"r\") as file:\n        vertex_shader_source = file.read()\n\n    with open(os.path.join(shader_dir, \"fragment_shader.glsl\"), \"r\") as file:\n        fragment_shader_source = file.read()\n\n    return self.opengl_context.program(\n        vertex_shader=vertex_shader_source, fragment_shader=fragment_shader_source\n    )\n</code></pre>"},{"location":"source/shader_program/#pynecraft.shader_program.ShaderProgram.set_uniforms","title":"<code>set_uniforms()</code>","text":"<p>Set the uniform variables of the shader program, the values of which remain constant for all vertices processed during a single draw call.</p> Source code in <code>pynecraft/shader_program.py</code> <pre><code>def set_uniforms(self):\n    \"\"\"Set the uniform variables of the shader program, the values of which\n    remain constant for all vertices processed during a single draw call.\n    \"\"\"\n    # Set the projection matrix uniform variable to the vertex shader\n    self.program[\"m_proj\"].write(self.player.projection_matrix)\n    # Set the model matrix uniform variable to the vertex shader\n    self.program[\"m_model\"].write(glm.mat4())\n</code></pre>"},{"location":"source/shader_program/#pynecraft.shader_program.ShaderProgram.update","title":"<code>update()</code>","text":"<p>Update the uniform variables of the shader program.</p> Source code in <code>pynecraft/shader_program.py</code> <pre><code>def update(self):\n    \"\"\"Update the uniform variables of the shader program.\"\"\"\n    # Set the view matrix uniform variable to the vertex shader\n    self.program[\"m_view\"].write(self.player.view_matrix)\n</code></pre>"},{"location":"source/mesh/base/","title":"Base-Mesh","text":""},{"location":"source/mesh/base/#base-mesh-class","title":"Base Mesh Class","text":""},{"location":"source/mesh/base/#pynecraft.mesh.base.BaseMesh","title":"<code>BaseMesh</code>","text":"<p>             Bases: <code>ABC</code></p> <p>A base class for a mesh object that can be rendered in an OpenGL context.</p> <p>Parameters:</p> Name Type Description Default <code>opengl_context</code> <code>Context</code> <p>The OpenGL context.</p> required <code>program</code> <code>Program</code> <p>The shader program used to render the mesh.</p> required Source code in <code>pynecraft/mesh/base.py</code> <pre><code>class BaseMesh(ABC):\n    \"\"\"A base class for a mesh object that can be rendered in an OpenGL context.\n\n    Args:\n        opengl_context (moderngl.Context): The OpenGL context.\n        program (moderngl.Program): The shader program used to render the mesh.\n    \"\"\"\n\n    def __init__(\n        self, opengl_context: moderngl.Context, program: moderngl.Program\n    ) -&gt; None:\n        super().__init__()\n        self.opengl_context = opengl_context\n        self.program = program\n        self.vbo_format: str = None\n        self.attributes: List[str] = None\n        self.vertex_array_object: moderngl.VertexArray = None\n\n    @abstractmethod\n    def get_vertex_data(self) -&gt; np.array:\n        \"\"\"Returns the vertex data for the mesh.\"\"\"\n        pass\n\n    def get_vertex_array_object(self) -&gt; moderngl.VertexArray:\n        \"\"\"Returns a VertexArray object for the mesh.\n\n        Returns:\n            moderngl.VertexArray: The VertexArray object.\n        \"\"\"\n        vertex_data = self.get_vertex_data()\n\n        # A vertex buffer object is an OpenGL object that stores vertex data\n        # such as position, color, texture coordinates, and normals in GPU\n        # memory, which is efficient for rendering because it minimizes the\n        # data transfer between CPU and GPU.\n        vertex_buffer_object = self.opengl_context.buffer(vertex_data)\n\n        # A vertext array object is an OpenGL object that stores the format of\n        # the vertex data as well as the method of extracting vertex data from\n        # one or more vertex buffer objects. Essentially it stores the parameters\n        # to interpret the vertex data structure.\n        vertex_array_object = self.opengl_context.vertex_array(\n            self.program,\n            [(vertex_buffer_object, self.vbo_format, *self.attributes)],\n            skip_errors=True,\n        )\n\n        return vertex_array_object\n\n    def render(self):\n        \"\"\"Renders the mesh.\"\"\"\n        self.vertex_array_object.render()\n</code></pre>"},{"location":"source/mesh/base/#pynecraft.mesh.base.BaseMesh.get_vertex_array_object","title":"<code>get_vertex_array_object()</code>","text":"<p>Returns a VertexArray object for the mesh.</p> <p>Returns:</p> Type Description <code>VertexArray</code> <p>moderngl.VertexArray: The VertexArray object.</p> Source code in <code>pynecraft/mesh/base.py</code> <pre><code>def get_vertex_array_object(self) -&gt; moderngl.VertexArray:\n    \"\"\"Returns a VertexArray object for the mesh.\n\n    Returns:\n        moderngl.VertexArray: The VertexArray object.\n    \"\"\"\n    vertex_data = self.get_vertex_data()\n\n    # A vertex buffer object is an OpenGL object that stores vertex data\n    # such as position, color, texture coordinates, and normals in GPU\n    # memory, which is efficient for rendering because it minimizes the\n    # data transfer between CPU and GPU.\n    vertex_buffer_object = self.opengl_context.buffer(vertex_data)\n\n    # A vertext array object is an OpenGL object that stores the format of\n    # the vertex data as well as the method of extracting vertex data from\n    # one or more vertex buffer objects. Essentially it stores the parameters\n    # to interpret the vertex data structure.\n    vertex_array_object = self.opengl_context.vertex_array(\n        self.program,\n        [(vertex_buffer_object, self.vbo_format, *self.attributes)],\n        skip_errors=True,\n    )\n\n    return vertex_array_object\n</code></pre>"},{"location":"source/mesh/base/#pynecraft.mesh.base.BaseMesh.get_vertex_data","title":"<code>get_vertex_data()</code>  <code>abstractmethod</code>","text":"<p>Returns the vertex data for the mesh.</p> Source code in <code>pynecraft/mesh/base.py</code> <pre><code>@abstractmethod\ndef get_vertex_data(self) -&gt; np.array:\n    \"\"\"Returns the vertex data for the mesh.\"\"\"\n    pass\n</code></pre>"},{"location":"source/mesh/base/#pynecraft.mesh.base.BaseMesh.render","title":"<code>render()</code>","text":"<p>Renders the mesh.</p> Source code in <code>pynecraft/mesh/base.py</code> <pre><code>def render(self):\n    \"\"\"Renders the mesh.\"\"\"\n    self.vertex_array_object.render()\n</code></pre>"},{"location":"source/mesh/quad/","title":"Quad-Mesh","text":""},{"location":"source/mesh/quad/#quad-mesh-class","title":"Quad Mesh Class","text":""},{"location":"source/mesh/quad/#pynecraft.mesh.quad.QuadMesh","title":"<code>QuadMesh</code>","text":"<p>             Bases: <code>BaseMesh</code></p> <p>A mesh representing a quad in 3D space.</p> <p>Parameters:</p> Name Type Description Default <code>opengl_context</code> <code>Context</code> <p>The OpenGL context.</p> required <code>program</code> <code>Program</code> <p>The shader program used to render the mesh.</p> required Source code in <code>pynecraft/mesh/quad.py</code> <pre><code>class QuadMesh(BaseMesh):\n    \"\"\"A mesh representing a quad in 3D space.\n\n    Args:\n        opengl_context (moderngl.Context): The OpenGL context.\n        program (moderngl.Program): The shader program used to render the mesh.\n    \"\"\"\n\n    def __init__(\n        self, opengl_context: moderngl.Context, program: moderngl.Program\n    ) -&gt; None:\n        super().__init__(opengl_context, program)\n\n        # This means that there are 2 sets of attributes consisting of 3 sets of\n        # floats per vertex.\n        self.vbo_format = \"3f 3f\"\n\n        # The attributes to be passed to the vertex shader\n        self.attributes = [\"in_position\", \"in_color\"]\n\n        self.vertex_array_object = self.get_vertex_array_object()\n\n    def get_vertex_data(self) -&gt; np.array:\n        \"\"\"Returns the vertex data for the mesh.\n\n        Returns:\n            np.array: The vertex data.\n        \"\"\"\n        vertices = [\n            (0.5, 0.5, 0.0),\n            (-0.5, 0.5, 0.0),\n            (-0.5, -0.5, 0.0),\n            (0.5, 0.5, 0.0),\n            (-0.5, -0.5, 0.0),\n            (0.5, -0.5, 0.0),\n        ]\n        colors = [(0, 1, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0), (1, 1, 0), (0, 0, 1)]\n        return np.hstack([vertices, colors], dtype=\"float32\")\n</code></pre>"},{"location":"source/mesh/quad/#pynecraft.mesh.quad.QuadMesh.get_vertex_data","title":"<code>get_vertex_data()</code>","text":"<p>Returns the vertex data for the mesh.</p> <p>Returns:</p> Type Description <code>array</code> <p>np.array: The vertex data.</p> Source code in <code>pynecraft/mesh/quad.py</code> <pre><code>def get_vertex_data(self) -&gt; np.array:\n    \"\"\"Returns the vertex data for the mesh.\n\n    Returns:\n        np.array: The vertex data.\n    \"\"\"\n    vertices = [\n        (0.5, 0.5, 0.0),\n        (-0.5, 0.5, 0.0),\n        (-0.5, -0.5, 0.0),\n        (0.5, 0.5, 0.0),\n        (-0.5, -0.5, 0.0),\n        (0.5, -0.5, 0.0),\n    ]\n    colors = [(0, 1, 0), (1, 0, 0), (1, 1, 0), (0, 1, 0), (1, 1, 0), (0, 0, 1)]\n    return np.hstack([vertices, colors], dtype=\"float32\")\n</code></pre>"}]}